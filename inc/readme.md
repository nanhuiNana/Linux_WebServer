# 头文件目录

## RAII
* "Resource Acquisition is Initialization" 直译为 “资源获取即初始化”
* 由于系统的资源不具有自动释放的功能，而C++中的类具有**自动调用析构函数**的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的**局部变量**的生命结束时，它的析构函数就会自动的被编译器调用，如此，就不用程序员显示的去调用释放资源的操作了。

## wrap.h
### 封装各种函数的异常操作
* 信号量API
* 互斥量API
* 条件变量API
* 数据库API

## Locker.h
### 封装多线程操作需要的各种锁
* 信号量
* 互斥量
* 条件变量

## BlockQueue.h
### 封装阻塞队列
* 在异步日志中，每个工作线程当有日志需要处理时，将所需写的日志内容封装后加入到阻塞队列中，而日志系统会单独分配一个写线程，不断地从阻塞队列中获得任务并写入日志文件中。

## Log.h
### 使用懒汉单例模式封装日志写入
#### 单例模式
* 单例模式保证了一个类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。
* 单例模式也分为两种，一种是懒汉模式：顾名思义，懒汉模式非常懒，当没有人用它的时候它就不初始化，只有被第一次使用时才去初始化；另一种是饿汉模式：与懒汉模式相反，程序运行时就立刻创建实例进行初始化。
* 经典的懒汉模式一般要使用双检测锁。但C++11之后，可以使用静态局部变量初始化，就不再需要锁，编译器会负责线程安全的问题。
* 懒汉单例模式——双检测锁
  ~~~cpp
    #include<iostream>
    #include<mutex>
    using namespace std;
    /*单例模式：构造函数私有化，对外提供一个接口*/ 
    //线程安全的单例模式
    class lhsingleClass {
    public:
	    static lhsingleClass* getinstance(){//双重锁模式
		    if (instance == nullptr){//先判断是否为空，如果为空则进入，不为空说明已经存在实例，直接返回
			i_mutex.lock();//进入后加锁
			if (instance == nullptr){//再判断一次，确保不会因为加锁期间多个线程同时进入
				instance = new lhsingleClass();
			}
			i_mutex.unlock();//解锁
		}
		return instance;
	    }
    private:
        static lhsingleClass* instance;
	    static mutex i_mutex;//锁
	    lhsingleClass(){}
    };
    lhsingleClass* lhsingleClass::instance=nullptr;
    mutex lhsingleClass::i_mutex;//类外初始化
  ~~~

## SqlConnectionPool.h
### 封装数据库连接池
* 池是什么
  * 在程序设计思想中，"池"（Pool）通常指的是一种资源管理的模式，其中资源被集中管理并通过预先分配而不是按需创建。这种模式可以用于多种类型的资源，比如：
    * 内存池
    * 线程池
    * 数据库连接池
* 在程序初始化时，我们就立刻创建多个数据连接，把它们集中管理。当程序需要使用时，就从“池”中取出使用，用完再放回池中，这样就避免了频繁的数据库连接和断开操作，而且更加地安全可靠。
* 对于数据库连接池，可以使用**单例模式**和**链表**来实现数据库连接池，同时利用**RAII机制**来释放数据连接