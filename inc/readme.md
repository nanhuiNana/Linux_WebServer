# 头文件目录

## RAII
* "Resource Acquisition is Initialization" 直译为 “资源获取即初始化”
* 由于系统的资源不具有自动释放的功能，而C++中的类具有**自动调用析构函数**的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的**局部变量**的生命结束时，它的析构函数就会自动的被编译器调用，如此，就不用程序员显示的去调用释放资源的操作了。

## wrap.h
### 封装各种函数的异常操作
* 信号量API
* 互斥量API
* 条件变量API
* 数据库API

## Locker.h
### 封装多线程操作需要的各种锁
* 信号量
* 互斥量
* 条件变量

## BlockQueue.h
### 封装阻塞队列
* 在异步日志中，每个工作线程当有日志需要处理时，将所需写的日志内容封装后加入到阻塞队列中，而日志系统会单独分配一个写线程，不断地从阻塞队列中获得任务并写入日志文件中。

## Log.h
### 使用懒汉单例模式封装日志写入
#### 单例模式
* 单例模式保证了一个类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。
* 单例模式也分为两种，一种是懒汉模式：顾名思义，懒汉模式非常懒，当没有人用它的时候它就不初始化，只有被第一次使用时才去初始化；另一种是饿汉模式：与懒汉模式相反，程序运行时就立刻创建实例进行初始化。
* 经典的懒汉模式一般要使用双检测锁。但C++11之后，可以使用静态局部变量初始化，就不再需要锁，编译器会负责线程安全的问题。
* 懒汉单例模式——双检测锁
  ~~~cpp
    #include<iostream>
    #include<mutex>
    using namespace std;
    /*单例模式：构造函数私有化，对外提供一个接口*/ 
    //线程安全的单例模式
    class lhsingleClass {
    public:
	    static lhsingleClass* getinstance(){//双重锁模式
		    if (instance == nullptr){//先判断是否为空，如果为空则进入，不为空说明已经存在实例，直接返回
			i_mutex.lock();//进入后加锁
			if (instance == nullptr){//再判断一次，确保不会因为加锁期间多个线程同时进入
				instance = new lhsingleClass();
			}
			i_mutex.unlock();//解锁
		}
		return instance;
	    }
    private:
        static lhsingleClass* instance;
	    static mutex i_mutex;//锁
	    lhsingleClass(){}
    };
    lhsingleClass* lhsingleClass::instance=nullptr;
    mutex lhsingleClass::i_mutex;//类外初始化
  ~~~

## SqlConnectionPool.h
### 封装数据库连接池
* 池是什么
  * 在程序设计思想中，"池"（Pool）通常指的是一种资源管理的模式，其中资源被集中管理并通过预先分配而不是按需创建。这种模式可以用于多种类型的资源，比如：
    * 内存池
    * 线程池
    * 数据库连接池
* 在程序初始化时，我们就立刻创建多个数据连接，把它们集中管理。当程序需要使用时，就从“池”中取出使用，用完再放回池中，这样就避免了频繁的数据库连接和断开操作，而且更加地安全可靠。
* 对于数据库连接池，可以使用**单例模式**和**链表**来实现数据库连接池，同时利用**RAII机制**来释放数据连接

## Timer.h
### 封装定时器
*  一个服务器程序不仅要处理读事件和写事件，还要处理的一类事件是定时事件。
*  什么是定时事件？
  * 定时事件是指在程序执行过程中，根据预先设定的时间间隔或特定的时间点，执行某些任务或动作的事件。
* 如何去使用定时事件？
  * 将每个定时事件封装成定时器，并用某种容器类数据结构将其统一的管理和保存，这个容器类数据结构称为定时器容器，常见的定时器容器有：升序链表，时间轮，时间堆；然后程序就可以定时去调用定时器完成定时事件。
##### 定时器类Timer
* 连接资源：套接字地址，文件描述符和定时器
* 超时时间：设定为绝对时间，即：浏览器和服务器连接的时刻 + 固定时间TIMESLOT
* 定时器指针：定义两个指针分别指向上升链表的前后定时器
#### 定时器容器类（双向链表）
* 添加定时器
* 调整定时器
* 删除定时器
* 心搏函数（定时任务处理函数）——将过期的定时器从链表中删除

## Utils.h
### 封装工具变量和函数
* 管道文件描述符
* epoll文件描述符
* 设置文件描述符非阻塞函数
* epoll注册读事件函数
* 信号处理函数
* 设置信号处理函数

## PthreadPool.h
### 封装线程池
* 空间换时间,浪费服务器的硬件资源,换取运行效率
* 池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源
* 当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配
* 当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源
### pthread_create陷阱
~~~c
#include <pthread.h>
int pthread_create (pthread_t *thread_tid,              //返回新生成的线程的id
                   const pthread_attr_t *attr,         //指向线程属性的指针,通常设置为NULL
                  void * (*start_routine) (void *),   //处理线程函数的地址
                   void *arg);                         //start_routine()中的参数
~~~
* pthread_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为**`(void *)`**,若线程函数为类成员函数，则this指针会作为默认的参数被传进函数中，从而和线程函数参数**`(void*)`**不能匹配，不能通过编译，而静态成员函数就没有这个问题，里面没有this指针，所以如果处理线程函数为类成员函数时，需要将其设置为**静态成员函数**
### 线程池分析
* 线程池的设计模式为半同步/半反应堆，其中反应堆具体为Proactor事件处理模式
* 主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理
### EPOLLONESHOT
* 一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket。我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里，一个线程处理socket时，其他线程将无法处理，**当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件**