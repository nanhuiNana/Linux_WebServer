# 头文件目录

## RAII
* "Resource Acquisition is Initialization" 直译为 “资源获取即初始化”
* 由于系统的资源不具有自动释放的功能，而C++中的类具有**自动调用析构函数**的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的**局部变量**的生命结束时，它的析构函数就会自动的被编译器调用，如此，就不用程序员显示的去调用释放资源的操作了。

## wrap.h
### 封装各种函数的异常操作
* 信号量API
* 互斥量API
* 条件变量API
* 数据库API

## Locker.h
### 封装多线程操作需要的各种锁
* 信号量
* 互斥量
* 条件变量

## BlockQueue.h
### 封装阻塞队列
* 在异步日志中，每个工作线程当有日志需要处理时，将所需写的日志内容封装后加入到阻塞队列中，而日志系统会单独分配一个写线程，不断地从阻塞队列中获得任务并写入日志文件中。

## Log.h
### 使用懒汉单例模式封装日志写入
#### 单例模式
* 单例模式保证了一个类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。
* 单例模式也分为两种，一种是懒汉模式：顾名思义，懒汉模式非常懒，当没有人用它的时候它就不初始化，只有被第一次使用时才去初始化；另一种是饿汉模式：与懒汉模式相反，程序运行时就立刻创建实例进行初始化。
* 经典的懒汉模式一般要使用双检测锁。但C++11之后，可以使用静态局部变量初始化，就不再需要锁，编译器会负责线程安全的问题。
* 懒汉单例模式——双检测锁
  ~~~cpp
    #include<iostream>
    #include<mutex>
    using namespace std;
    /*单例模式：构造函数私有化，对外提供一个接口*/ 
    //线程安全的单例模式
    class lhsingleClass {
    public:
	    static lhsingleClass* getinstance(){//双重锁模式
		    if (instance == nullptr){//先判断是否为空，如果为空则进入，不为空说明已经存在实例，直接返回
			i_mutex.lock();//进入后加锁
			if (instance == nullptr){//再判断一次，确保不会因为加锁期间多个线程同时进入
				instance = new lhsingleClass();
			}
			i_mutex.unlock();//解锁
		}
		return instance;
	    }
    private:
        static lhsingleClass* instance;
	    static mutex i_mutex;//锁
	    lhsingleClass(){}
    };
    lhsingleClass* lhsingleClass::instance=nullptr;
    mutex lhsingleClass::i_mutex;//类外初始化
  ~~~

## SqlConnectionPool.h
### 封装数据库连接池
* 池是什么
  * 在程序设计思想中，"池"（Pool）通常指的是一种资源管理的模式，其中资源被集中管理并通过预先分配而不是按需创建。这种模式可以用于多种类型的资源，比如：
    * 内存池
    * 线程池
    * 数据库连接池
* 在程序初始化时，我们就立刻创建多个数据连接，把它们集中管理。当程序需要使用时，就从“池”中取出使用，用完再放回池中，这样就避免了频繁的数据库连接和断开操作，而且更加地安全可靠。
* 对于数据库连接池，可以使用**单例模式**和**链表**来实现数据库连接池，同时利用**RAII机制**来释放数据连接

## Timer.h
### 封装定时器
*  一个服务器程序不仅要处理读事件和写事件，还要处理的一类事件是定时事件。
*  什么是定时事件？
  * 定时事件是指在程序执行过程中，根据预先设定的时间间隔或特定的时间点，执行某些任务或动作的事件。
* 如何去使用定时事件？
  * 将每个定时事件封装成定时器，并用某种容器类数据结构将其统一的管理和保存，这个容器类数据结构称为定时器容器，常见的定时器容器有：升序链表，时间轮，时间堆；然后程序就可以定时去调用定时器完成定时事件。
##### 定时器类Timer
* 连接资源：套接字地址，文件描述符和定时器
* 超时时间：设定为绝对时间，即：浏览器和服务器连接的时刻 + 固定时间TIMESLOT
* 定时器指针：定义两个指针分别指向上升链表的前后定时器
#### 定时器容器类（双向链表）
* 添加定时器
* 调整定时器
* 删除定时器
* 心搏函数（定时任务处理函数）——将过期的定时器从链表中删除

## Utils.h
### 封装工具变量和函数
* 管道文件描述符
* epoll文件描述符
* 设置文件描述符非阻塞函数
* epoll注册读事件函数
* 信号处理函数
* 设置信号处理函数